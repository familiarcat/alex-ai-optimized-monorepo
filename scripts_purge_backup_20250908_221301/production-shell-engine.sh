#!/bin/bash

# Production Shell Script Engine
# Bulletproof shell script generation with comprehensive error handling

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATES_DIR="${SCRIPT_DIR}/templates"
OUTPUT_DIR="${SCRIPT_DIR}/generated"
LOG_FILE="${SCRIPT_DIR}/shell-engine.log"

# Ensure directories exist
mkdir -p "$TEMPLATES_DIR" "$OUTPUT_DIR"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Error handling
handle_error() {
    local exit_code=$?
    local line_number=$1
    log "ERROR: Script failed at line $line_number with exit code $exit_code"
    exit $exit_code
}

trap 'handle_error $LINENO' ERR

# Validation functions
validate_script_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+\.sh$ ]]; then
        log "ERROR: Invalid script name '$name'. Must be alphanumeric with .sh extension"
        return 1
    fi
    return 0
}

validate_output_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        log "ERROR: Output directory '$dir' does not exist"
        return 1
    fi
    return 0
}

# Safe string output function
safe_output() {
    local message="$1"
    printf '%s\n' "$message"
}

# Generate basic script template
generate_basic_script() {
    local script_name="$1"
    local output_path="$2"
    
    log "Generating basic script: $script_name"
    
    cat > "$output_path" << 'EOF'
#!/bin/bash

# Generated by Production Shell Engine
# Timestamp: TIMESTAMP_PLACEHOLDER

set -euo pipefail

# Configuration
SCRIPT_NAME="$(basename "$0")"
LOG_FILE="/tmp/${SCRIPT_NAME}.log"

# Logging function
log() {
    printf '%s\n' "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Main execution
main() {
    log "Starting $SCRIPT_NAME"
    
    # Add your logic here
    
    log "Completed $SCRIPT_NAME"
}

# Error handling
handle_error() {
    local exit_code=$?
    local line_number=$1
    log "ERROR: Script failed at line $line_number with exit code $exit_code"
    exit $exit_code
}

trap 'handle_error $LINENO' ERR

# Execute main function
main "$@"
EOF

    # Replace timestamp placeholder
    sed -i.bak "s/TIMESTAMP_PLACEHOLDER/$(date -u +%Y-%m-%dT%H:%M:%SZ)/" "$output_path"
    rm -f "${output_path}.bak"
    
    chmod +x "$output_path"
    log "Generated script: $output_path"
}

# Generate status script template
generate_status_script() {
    local script_name="$1"
    local output_path="$2"
    
    log "Generating status script: $script_name"
    
    cat > "$output_path" << 'EOF'
#!/bin/bash

# Status Script Template
# Generated by Production Shell Engine

set -euo pipefail

# Safe output function
output() {
    printf '%s\n' "$1"
}

# Main status function
show_status() {
    output "System Status"
    output "============="
    output ""
    output "Status: Running"
    output "Timestamp: $(date)"
    output "Process ID: $$"
    output ""
    output "System Information:"
    output "  OS: $(uname -s)"
    output "  Architecture: $(uname -m)"
    output "  Shell: $SHELL"
    output ""
    output "Status: Complete"
}

# Execute
show_status "$@"
EOF

    chmod +x "$output_path"
    log "Generated status script: $output_path"
}

# Generate progress script template
generate_progress_script() {
    local script_name="$1"
    local output_path="$2"
    
    log "Generating progress script: $script_name"
    
    cat > "$output_path" << 'EOF'
#!/bin/bash

# Progress Script Template
# Generated by Production Shell Engine

set -euo pipefail

# Progress tracking
PROGRESS=0
TOTAL_STEPS=5

# Safe output function
output() {
    printf '%s\n' "$1"
}

# Update progress
update_progress() {
    local step="$1"
    local description="$2"
    
    PROGRESS=$((PROGRESS + 1))
    local percentage=$((PROGRESS * 100 / TOTAL_STEPS))
    
    output "Step $PROGRESS/$TOTAL_STEPS: $description"
    output "Progress: $percentage%"
    output ""
}

# Main progress function
run_progress() {
    output "Starting Progress Tracking"
    output "=========================="
    output ""
    
    update_progress 1 "Initializing system"
    sleep 1
    
    update_progress 2 "Loading configuration"
    sleep 1
    
    update_progress 3 "Processing data"
    sleep 1
    
    update_progress 4 "Validating results"
    sleep 1
    
    update_progress 5 "Finalizing"
    
    output "Progress: 100%"
    output "Status: Complete"
}

# Execute
run_progress "$@"
EOF

    chmod +x "$output_path"
    log "Generated progress script: $output_path"
}

# Test generated script
test_script() {
    local script_path="$1"
    
    log "Testing script: $script_path"
    
    if [[ ! -f "$script_path" ]]; then
        log "ERROR: Script file does not exist: $script_path"
        return 1
    fi
    
    if [[ ! -x "$script_path" ]]; then
        log "ERROR: Script is not executable: $script_path"
        return 1
    fi
    
    # Run script and capture output
    local output
    if output=$("$script_path" 2>&1); then
        log "SUCCESS: Script executed without errors"
        log "Output: $output"
        return 0
    else
        log "ERROR: Script execution failed"
        log "Output: $output"
        return 1
    fi
}

# Main generation function
generate_script() {
    local script_name="$1"
    local script_type="${2:-basic}"
    local output_dir="${3:-$OUTPUT_DIR}"
    
    # Validate inputs
    if ! validate_script_name "$script_name"; then
        return 1
    fi
    
    if ! validate_output_directory "$output_dir"; then
        return 1
    fi
    
    local output_path="${output_dir}/${script_name}"
    
    # Generate based on type
    case "$script_type" in
        "basic")
            generate_basic_script "$script_name" "$output_path"
            ;;
        "status")
            generate_status_script "$script_name" "$output_path"
            ;;
        "progress")
            generate_progress_script "$script_name" "$output_path"
            ;;
        *)
            log "ERROR: Unknown script type: $script_type"
            return 1
            ;;
    esac
    
    # Test the generated script
    if test_script "$output_path"; then
        log "SUCCESS: Script generation and testing completed"
        return 0
    else
        log "ERROR: Script generation failed testing"
        return 1
    fi
}

# Batch generation function
generate_batch() {
    local output_dir="${1:-$OUTPUT_DIR}"
    
    log "Starting batch script generation"
    
    local scripts=(
        "test-basic.sh:basic"
        "test-status.sh:status"
        "test-progress.sh:progress"
    )
    
    local success_count=0
    local total_count=${#scripts[@]}
    
    for script_info in "${scripts[@]}"; do
        IFS=':' read -r script_name script_type <<< "$script_info"
        
        if generate_script "$script_name" "$script_type" "$output_dir"; then
            ((success_count++))
        fi
    done
    
    log "Batch generation complete: $success_count/$total_count successful"
    
    if [[ $success_count -eq $total_count ]]; then
        return 0
    else
        return 1
    fi
}

# Main execution
main() {
    log "Production Shell Engine starting"
    
    case "${1:-help}" in
        "generate")
            generate_script "${2:-}" "${3:-basic}" "${4:-$OUTPUT_DIR}"
            ;;
        "batch")
            generate_batch "${2:-$OUTPUT_DIR}"
            ;;
        "test")
            test_script "${2:-}"
            ;;
        "help"|*)
            safe_output "Production Shell Engine"
            safe_output "========================"
            safe_output ""
            safe_output "Usage: $0 <command> [options]"
            safe_output ""
            safe_output "Commands:"
            safe_output "  generate <script_name> [type] [output_dir]"
            safe_output "  batch [output_dir]"
            safe_output "  test <script_path>"
            safe_output "  help"
            safe_output ""
            safe_output "Script types: basic, status, progress"
            safe_output ""
            safe_output "Examples:"
            safe_output "  $0 generate my-script.sh basic"
            safe_output "  $0 generate status.sh status"
            safe_output "  $0 batch"
            safe_output "  $0 test generated/my-script.sh"
            ;;
    esac
}

# Execute main function
main "$@"
